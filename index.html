<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Smart Steg PRO - Lagerverwaltung</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@0.344.0/dist/umd/lucide.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
    body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; background-color: #f8fafc; }
    .custom-scrollbar::-webkit-scrollbar { height: 6px; width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #facc15; border-radius: 10px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #0f172a; }
    .grid-cell { transition: all 0.2s ease-in-out; }
    .grid-cell:active { transform: scale(0.92); }
    .glass-effect { background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(10px); }
  </style>
</head>

<body class="bg-slate-50">
<div id="root"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
  import {
    getFirestore,
    collection, collectionGroup,
    doc, setDoc,
    onSnapshot, deleteDoc, updateDoc, getDoc,
    query, where, orderBy, limit,
    runTransaction, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

  window.FirebaseSDK = {
    initializeApp,
    getFirestore,
    collection, collectionGroup,
    doc, setDoc,
    onSnapshot, deleteDoc, updateDoc, getDoc,
    query, where, orderBy, limit,
    runTransaction, serverTimestamp,
    getAuth, signInAnonymously, onAuthStateChanged
  };
</script>

<script type="text/babel">
  const { useState, useEffect, useMemo, useCallback, useRef } = React;
  const {
    initializeApp, getFirestore,
    collection, collectionGroup,
    doc, setDoc,
    onSnapshot, deleteDoc, updateDoc, getDoc,
    query, where, orderBy, limit,
    runTransaction, serverTimestamp,
    getAuth, signInAnonymously, onAuthStateChanged
  } = window.FirebaseSDK;

  const firebaseConfig = {
    apiKey: "AIzaSyBGqPXXcmJTbL3PVrn-PKL0Gig45r6GPbQ",
    authDomain: "steg-lager-test.firebaseapp.com",
    databaseURL: "https://steg-lager-test-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "steg-lager-test",
    storageBucket: "steg-lager-test.firebasestorage.app",
    messagingSenderId: "655203951825",
    appId: "1:655203951825:web:9edcfb40f29ed70f61d1f0",
    measurementId: "G-Q6FX41P556"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const APP_ID = "stege-lager-v1";

  const Icon = ({ name, size = 20, className = "" }) => (
    <i data-lucide={name} style={{ width: size, height: size }} className={className}></i>
  );

  // robustere Doc-ID
  const safeDocId = (s) => {
    const x = String(s ?? "")
      .trim()
      .replace(/\s+/g, " ")
      .replace(/\//g, "_")
      .replace(/[#?%\\]/g, "_");
    return x || "EMPTY";
  };

  const slotIdFrom = (shelf, level) => `${String(shelf)}_L${Number(level)}`;

  // derive slotId/shelf/level from path: artifacts/{appId}/public/data/slots/{slotId}/items/{itemId}
  const deriveFromPath = (path) => {
    const parts = String(path).split("/");
    const idx = parts.indexOf("slots");
    if (idx === -1) return { slotId: null, shelf: null, level: null };
    const slotId = parts[idx + 1] || null;
    if (!slotId) return { slotId: null, shelf: null, level: null };

    const m = String(slotId).match(/^(.+)_L(\d+)$/);
    if (!m) return { slotId, shelf: null, level: null };
    return { slotId, shelf: m[1], level: Number(m[2]) };
  };

  // --- Scan / Slot helpers ---
  const parseScanCode = (raw) => {
    const code = String(raw || "").trim();
    if (!code) return { kind: "unknown", value: "" };

    const upper = code.toUpperCase();

    // Slot: C12_L3
    if (/^C\d+_L\d+$/.test(upper)) {
      const [shelf, l] = upper.split("_L");
      return { kind: "slot", shelf, level: Number(l), value: upper };
    }

    // Alternative Slot formats: C12-L3, C12L3
    const m1 = upper.match(/^(C\d+)[-_ ]?L(\d+)$/);
    if (m1) return { kind: "slot", shelf: m1[1], level: Number(m1[2]), value: `${m1[1]}_L${m1[2]}` };

    // Shelf: C12
    if (/^C\d+$/.test(upper)) {
      return { kind: "shelf", shelf: upper, value: upper };
    }

    // else treat as itemKey (Steg/Artikelcode)
    return { kind: "item", itemKey: code, value: code };
  };

  // oberste belegte Ebene (levelsDesc ist [5,4,3,2,1])
  const pickTopOccupiedLevel = (slotMap, shelf, levelsDesc) => {
    for (const lvl of levelsDesc) {
      const key = `${shelf}|${lvl}`;
      const entries = slotMap.get(key) || [];
      if (entries.length) return lvl;
    }
    return null;
  };

  // nächste freie Ebene (von oben nach unten)
  const pickNextFreeLevel = (slotMap, shelf, levelsDesc) => {
    for (const lvl of levelsDesc) {
      const key = `${shelf}|${lvl}`;
      const entries = slotMap.get(key) || [];
      if (!entries.length) return lvl;
    }
    return null;
  };

  // ---------- CSV helpers ----------
  const fmtDateTime = (ts) => {
    try {
      if (!ts) return "";
      const d = typeof ts?.toDate === "function" ? ts.toDate() : (ts instanceof Date ? ts : new Date(ts));
      if (Number.isNaN(d.getTime())) return "";
      return new Intl.DateTimeFormat("de-DE", {
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit"
      }).format(d);
    } catch { return ""; }
  };

  const csvEscape = (v) => `"${String(v ?? "").replace(/"/g, '""')}"`;

  const downloadTextFile = (filename, text, mime = "text/plain;charset=utf-8") => {
    const blob = new Blob([text], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // ---------- Scanner Modal (BarcodeDetector) ----------
  const ScannerModal = ({ open, title = "Scan", onClose, onResult }) => {
    const [error, setError] = useState("");
    const [manual, setManual] = useState("");
    const videoRef = useRef(null);
    const streamRef = useRef(null);
    const detectorRef = useRef(null);
    const rafRef = useRef(null);

    const stop = useCallback(() => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = null;

      if (streamRef.current) {
        streamRef.current.getTracks().forEach(t => t.stop());
        streamRef.current = null;
      }
    }, []);

    useEffect(() => {
      if (!open) { stop(); return; }

      const start = async () => {
        setError("");
        try {
          if (!("BarcodeDetector" in window)) {
            setError("BarcodeDetector nicht verfügbar. Bitte Code manuell eingeben.");
            return;
          }
          detectorRef.current = new window.BarcodeDetector({
            formats: ["qr_code","code_128","code_39","ean_13","ean_8","itf","upc_a","upc_e"]
          });

          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
            audio: false
          });
          streamRef.current = stream;

          const video = videoRef.current;
          video.srcObject = stream;
          await video.play();

          const loop = async () => {
            try {
              if (!detectorRef.current || !videoRef.current) return;
              const barcodes = await detectorRef.current.detect(videoRef.current);
              if (barcodes && barcodes.length) {
                const val = barcodes[0].rawValue || "";
                if (val) {
                  stop();
                  onResult(val);
                  return;
                }
              }
            } catch (e) {
              // ignore occasional detect errors
            }
            rafRef.current = requestAnimationFrame(loop);
          };
          rafRef.current = requestAnimationFrame(loop);
        } catch (e) {
          console.error(e);
          setError("Kamera-Scan fehlgeschlagen. Bitte Code manuell eingeben.");
        }
      };

      start();
      return () => stop();
    }, [open, onResult, stop]);

    if (!open) return null;

    return (
      <div className="fixed inset-0 z-[2000] bg-black/60 backdrop-blur-sm flex items-end sm:items-center justify-center p-4">
        <div className="w-full max-w-lg bg-white rounded-[2rem] shadow-2xl border border-slate-200 overflow-hidden">
          <div className="p-5 flex items-center justify-between">
            <div className="font-black text-slate-900">{title}</div>
            <button
              onClick={() => { stop(); onClose(); }}
              className="px-3 py-2 rounded-xl bg-slate-100 font-black text-slate-700 active:scale-95"
            >
              Schließen
            </button>
          </div>

          <div className="px-5 pb-5 space-y-4">
            {error ? (
              <div className="p-4 bg-rose-50 border border-rose-100 rounded-2xl text-rose-700 font-bold text-sm">
                {error}
              </div>
            ) : (
              <div className="rounded-2xl overflow-hidden border border-slate-200 bg-black">
                <video ref={videoRef} className="w-full h-64 object-cover" playsInline />
              </div>
            )}

            <div className="p-4 bg-slate-50 border border-slate-100 rounded-2xl">
              <div className="text-[10px] font-black uppercase text-slate-400">Fallback</div>
              <div className="flex gap-2 mt-2">
                <input
                  value={manual}
                  onChange={e => setManual(e.target.value)}
                  placeholder="Code eintippen (z.B. C12_L3 oder STEG-123)"
                  className="flex-1 px-4 py-3 rounded-2xl border border-slate-200 font-bold outline-none"
                />
                <button
                  onClick={() => {
                    const v = manual.trim();
                    if (!v) return;
                    stop();
                    onResult(v);
                  }}
                  className="px-4 py-3 rounded-2xl bg-slate-900 text-yellow-500 font-black active:scale-95"
                >
                  OK
                </button>
              </div>
            </div>

            <div className="text-[11px] text-slate-500 font-bold">
              Unterstützt: QR + gängige Barcodes. Slots: <span className="text-slate-800">C12_L3</span> oder Regal: <span className="text-slate-800">C12</span>.
            </div>
          </div>
        </div>
      </div>
    );
  };

  const NavBtn = ({ active, onClick, icon, label, color = "yellow" }) => {
    const activeColors = {
      yellow: "bg-yellow-500 text-slate-900",
      emerald: "bg-emerald-500 text-white",
      rose: "bg-rose-500 text-white",
      blue: "bg-blue-500 text-white",
      slate: "bg-slate-700 text-white"
    };
    return (
      <button onClick={onClick}
        className={`flex flex-col items-center gap-1 p-2.5 px-3 rounded-3xl transition-all duration-300 ${
          active ? (activeColors[color] + " scale-105 shadow-xl") : "text-slate-500 hover:text-slate-300"
        }`}>
        <Icon name={icon} size={18} />
        <span className="text-[7px] font-black uppercase tracking-tighter">{label}</span>
      </button>
    );
  };

  function App() {
    const [activeTab, setActiveTab] = useState("dashboard");
    const [loading, setLoading] = useState(true);
    const [user, setUser] = useState(null);

    const [rawItems, setRawItems] = useState([]);
    const [stegItems, setStegItems] = useState([]);
    const [masterItems, setMasterItems] = useState([]);

    // movements
    const [movements, setMovements] = useState([]);
    const [historyQuery, setHistoryQuery] = useState("");

    const [searchQuery, setSearchQuery] = useState("");

    // forms
    const [newStock, setNewStock] = useState({ itemKey: "", shelf: "C1", level: 1, qty: "", source: "anlieferung" });
    const [outStock, setOutStock] = useState({ entryId: "", qty: "", destination: "produktion" });
    const [moveStock, setMoveStock] = useState({ entryId: "", targetShelf: "C1", targetLevel: 1, qty: "" });

    // Toast
    const [toast, setToast] = useState(null);
    const pushToast = useCallback((type, msg) => {
      setToast({ type, msg, id: Math.random().toString(36).slice(2) });
      window.clearTimeout(pushToast.__t);
      pushToast.__t = window.setTimeout(() => setToast(null), 2600);
    }, []);

    // Slot popup
    const [slotPopup, setSlotPopup] = useState({ open: false, shelf: null, level: null });

    // Scan add
    const [scanAddOpen, setScanAddOpen] = useState(false);
    const [scanAddMode, setScanAddMode] = useState("item"); // "item" | "slot"

    // Scan move (batch logic)
    const [scanMoveOpen, setScanMoveOpen] = useState(false);
    const [scanMoveMode, setScanMoveMode] = useState("source"); // "source" | "target"
    const [scanMoveBatch, setScanMoveBatch] = useState({
      hasSource: false,
      sourceShelf: null,
      sourceLevel: null,
      sourceSlotId: null,
      entries: []
    });

    const shelves = useMemo(() => Array.from({ length: 38 }, (_, i) => `C${i + 1}`), []);
    const levels = [5, 4, 3, 2, 1];

    // Firestore refs
    const slotDocRef = (slotId) => doc(db, "artifacts", APP_ID, "public", "data", "slots", slotId);
    const itemDocRef = (slotId, itemKey) => doc(db, "artifacts", APP_ID, "public", "data", "slots", slotId, "items", safeDocId(itemKey));
    const movementsColRef = () => collection(db, "artifacts", APP_ID, "public", "data", "movements");

    useEffect(() => {
      const init = async () => {
        try { await signInAnonymously(auth); }
        catch (e) { console.error("Auth Error:", e); }
      };
      init();

      const unsub = onAuthStateChanged(auth, (u) => {
        if (u) { setUser(u); setLoading(false); }
      });
      return () => unsub();
    }, []);

    useEffect(() => {
      if (window.lucide) window.lucide.createIcons();
    }, [
      activeTab,
      rawItems.length,
      stegItems.length,
      movements.length,
      toast?.id,
      slotPopup.open,
      scanAddOpen,
      scanMoveOpen
    ]);

    useEffect(() => {
      if (!user) return;

      let unsubItems = null;

      // Try scoped collectionGroup(items) by appId; fallback to unfiltered
      const startItemsListener = () => {
        const scopedQ = query(collectionGroup(db, "items"), where("appId", "==", APP_ID));
        unsubItems = onSnapshot(
          scopedQ,
          (snap) => {
            const docs = snap.docs.map(d => ({ __path: d.ref.path, __id: d.id, ...d.data() }));
            setRawItems(docs);
          },
          (err) => {
            console.warn("Scoped items query failed, fallback collectionGroup(items):", err);
            const fallbackQ = query(collectionGroup(db, "items"));
            if (unsubItems) unsubItems();
            unsubItems = onSnapshot(
              fallbackQ,
              (snap) => {
                const docs = snap.docs.map(d => ({ __path: d.ref.path, __id: d.id, ...d.data() }));
                setRawItems(docs);
              },
              (err2) => console.error("Fallback items fetch error:", err2)
            );
          }
        );
      };

      startItemsListener();

      const unsubSteg = onSnapshot(
        collection(db, "artifacts", APP_ID, "public", "data", "steg_items"),
        (snap) => {
          const items = snap.docs.map(d => {
            const data = d.data();
            return { id: d.id, code: data.code || data.name || d.id, ...data };
          }).sort((a,b) => String(a.code).localeCompare(String(b.code)));
          setStegItems(items);
        },
        (err) => console.error("Steg items fetch error:", err)
      );

      const unsubMaster = onSnapshot(
        collection(db, "artifacts", APP_ID, "public", "data", "master_items"),
        (snap) => setMasterItems(snap.docs.map(d => ({ id: d.id, ...d.data() }))),
        (err) => console.error("Master items fetch error:", err)
      );

      // movements live (latest 300)
      const movQ = query(movementsColRef(), orderBy("at", "desc"), limit(300));
      const unsubMov = onSnapshot(
        movQ,
        (snap) => {
          const docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));
          setMovements(docs);
        },
        (err) => console.error("Movements fetch error:", err)
      );

      return () => { if (unsubItems) unsubItems(); unsubSteg(); unsubMaster(); unsubMov(); };
    }, [user]);

    // Normalize item docs
    const itemDocs = useMemo(() => {
      const out = [];

      for (const d of rawItems) {
        const path = d.__path || "";
        const pathHasApp = path.includes(`artifacts/${APP_ID}/`);
        const fieldHasApp = String(d.appId || "") === APP_ID;
        if (!pathHasApp && !fieldHasApp) continue;

        const derived = deriveFromPath(path);

        const shelf = d.shelf ?? d.location?.shelf ?? derived.shelf;
        const level = Number(d.level ?? d.location?.level ?? derived.level);
        const slotId = d.slotId ?? derived.slotId ?? (shelf && level ? slotIdFrom(shelf, level) : null);

        const itemKey = d.itemKey ?? d.key ?? d.code ?? d.__id;
        const quantity = Number(d.quantity) || 0;

        if (!shelf || !level || !slotId || !itemKey) continue;
        if (quantity <= 0) continue;

        out.push({
          id: `${slotId}__${safeDocId(itemKey)}`,
          firestoreId: d.__id,
          path,
          appId: d.appId || APP_ID,
          slotId,
          shelf,
          level,
          itemKey: String(itemKey),
          quantity
        });
      }

      return out;
    }, [rawItems]);

    // slotMap for dashboard/inventory
    const slotMap = useMemo(() => {
      const m = new Map();
      for (const it of itemDocs) {
        const key = `${it.shelf}|${it.level}`;
        if (!m.has(key)) m.set(key, []);
        m.get(key).push(it);
      }
      for (const [k, arr] of m.entries()) {
        arr.sort((a,b) => String(a.itemKey).localeCompare(String(b.itemKey)));
        m.set(k, arr);
      }
      return m;
    }, [itemDocs]);

    const occupiedSlots = slotMap.size;
    const totalParts = useMemo(() => itemDocs.reduce((s, x) => s + (Number(x.quantity)||0), 0), [itemDocs]);

    // AWB index
    const awbIndex = useMemo(() => {
      const m = new Map();
      for (const it of masterItems) {
        const awb = it?.awb ? String(it.awb) : null;
        if (!awb) continue;
        for (const steg of [it?.steg1, it?.steg2]) {
          if (!steg) continue;
          const key = String(steg).toUpperCase();
          if (!m.has(key)) m.set(key, new Set());
          m.get(key).add(awb);
        }
      }
      return m;
    }, [masterItems]);

    const getLinkedAWBs = (stegCode) => {
      const s = awbIndex.get(String(stegCode || "").toUpperCase());
      return s ? Array.from(s) : [];
    };

    // grouped slots
    const groupedSlots = useMemo(() => {
      const rows = Array.from(slotMap.entries()).map(([key, entries]) => {
        const [shelf, levelStr] = key.split("|");
        return { shelf, level: Number(levelStr), entries };
      });
      const shelfNum = (s) => Number(String(s).replace("C","")) || 0;
      rows.sort((a,b) => {
        const ds = shelfNum(a.shelf) - shelfNum(b.shelf);
        if (ds !== 0) return ds;
        return b.level - a.level;
      });
      return rows;
    }, [slotMap]);

    const filteredSlots = useMemo(() => {
      const term = searchQuery.trim().toUpperCase();
      if (!term) return groupedSlots;
      return groupedSlots.map(slot => {
        const shelfMatch = String(slot.shelf).toUpperCase().includes(term);
        const matched = slot.entries.filter(e => {
          const keyMatch = String(e.itemKey).toUpperCase().includes(term);
          const awbMatch = getLinkedAWBs(e.itemKey).some(a => String(a).toUpperCase().includes(term));
          return keyMatch || awbMatch;
        });
        const entriesToShow = shelfMatch ? slot.entries : matched;
        if (!entriesToShow.length) return null;
        return { ...slot, entries: entriesToShow };
      }).filter(Boolean);
    }, [groupedSlots, searchQuery, awbIndex]);

    const entryOptions = useMemo(() => {
      const shelfNum = (s) => Number(String(s).replace("C","")) || 0;
      const arr = itemDocs.map(x => ({
        entryId: `${x.slotId}__${safeDocId(x.itemKey)}`,
        slotId: x.slotId,
        shelf: x.shelf,
        level: x.level,
        itemKey: x.itemKey,
        quantity: x.quantity
      }));
      arr.sort((a,b) => {
        const ds = shelfNum(a.shelf) - shelfNum(b.shelf);
        if (ds !== 0) return ds;
        const dl = b.level - a.level;
        if (dl !== 0) return dl;
        return String(a.itemKey).localeCompare(String(b.itemKey));
      });
      return arr;
    }, [itemDocs]);

    // ---------- CSV Export ----------
    const exportInventoryCSV = () => {
      const header = ["shelf","level","slotId","itemKey","quantity","linkedAWBs"].map(csvEscape).join(",");
      const rows = itemDocs
        .slice()
        .sort((a,b) => (a.shelf.localeCompare(b.shelf) || (b.level - a.level) || a.itemKey.localeCompare(b.itemKey)))
        .map(x => {
          const awbs = getLinkedAWBs(x.itemKey).join(" | ");
          return [x.shelf, x.level, x.slotId, x.itemKey, x.quantity, awbs].map(csvEscape).join(",");
        });
      const csv = [header, ...rows].join("\n");
      downloadTextFile(`bestand_${APP_ID}.csv`, csv, "text/csv;charset=utf-8");
      pushToast("ok", "Bestand CSV exportiert.");
    };

    const exportMovementsCSV = () => {
      const header = ["at","type","itemKey","qty","fromSlot","toSlot","source","destination","userId"].map(csvEscape).join(",");
      const rows = movements.map(m => {
        const fromSlot = m?.from?.slotId || "";
        const toSlot   = m?.to?.slotId || "";
        return [
          fmtDateTime(m.at),
          m.type || "",
          m.itemKey || "",
          m.qty ?? "",
          fromSlot,
          toSlot,
          m.source || "",
          m.destination || "",
          m.userId || ""
        ].map(csvEscape).join(",");
      });
      const csv = [header, ...rows].join("\n");
      downloadTextFile(`bewegungen_${APP_ID}.csv`, csv, "text/csv;charset=utf-8");
      pushToast("ok", "Bewegungen CSV exportiert.");
    };

    // History filtering
    const filteredMovements = useMemo(() => {
      const term = historyQuery.trim().toUpperCase();
      if (!term) return movements;
      return movements.filter(m => {
        const t = [
          m.type, m.itemKey, m.source, m.destination, m.userId,
          m?.from?.slotId, m?.to?.slotId
        ].filter(Boolean).join(" ").toUpperCase();
        return t.includes(term);
      });
    }, [movements, historyQuery]);

    // ---------- Write handlers ----------
    const handleAddStock = async (e) => {
      e.preventDefault();
      const qty = Number(newStock.qty);
      const itemKey = newStock.itemKey;
      const shelf = newStock.shelf;
      const level = Number(newStock.level);
      if (!itemKey || !shelf || !level || !qty || qty <= 0) return;

      const slotId = `${shelf}_L${level}`;
      const sRef = slotDocRef(slotId);
      const iRef = itemDocRef(slotId, itemKey);

      try {
        await runTransaction(db, async (tx) => {
          tx.set(sRef, { appId: APP_ID, slotId, shelf, level, updatedAt: serverTimestamp() }, { merge: true });

          const snap = await tx.get(iRef);
          const prev = snap.exists() ? (Number(snap.data().quantity) || 0) : 0;
          const next = prev + qty;

          if (snap.exists()) {
            tx.update(iRef, {
              appId: APP_ID, slotId, shelf, level, itemKey,
              quantity: next,
              updatedAt: serverTimestamp(),
              lastSource: newStock.source
            });
          } else {
            tx.set(iRef, {
              appId: APP_ID, slotId, shelf, level,
              itemKey, type: "steg",
              quantity: next,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
              lastSource: newStock.source
            });
          }

          tx.set(doc(movementsColRef()), {
            type: "in",
            itemKey,
            qty,
            source: newStock.source,
            to: { slotId, shelf, level },
            userId: user?.uid || null,
            at: serverTimestamp()
          });
        });

        setNewStock({ ...newStock, qty: "", itemKey: "" });
        setActiveTab("inventory");
        pushToast("ok", "Einlagerung gespeichert.");
      } catch (err) {
        console.error("Add error:", err);
        pushToast("err", "Fehler beim Einlagern (siehe Konsole).");
      }
    };

    const handleRemoveStock = async (e) => {
      e.preventDefault();
      const qty = Number(outStock.qty);
      if (!outStock.entryId || !qty || qty <= 0) return;

      const selected = entryOptions.find(x => x.entryId === outStock.entryId);
      if (!selected) return;
      if (selected.quantity < qty) { pushToast("err", "Nicht genug Bestand."); return; }

      const iRef = itemDocRef(selected.slotId, selected.itemKey);

      try {
        await runTransaction(db, async (tx) => {
          const snap = await tx.get(iRef);
          const prev = snap.exists() ? (Number(snap.data().quantity) || 0) : 0;
          if (prev < qty) throw new Error("Insufficient stock in transaction");

          const next = prev - qty;
          if (next <= 0) tx.delete(iRef);
          else tx.update(iRef, { quantity: next, updatedAt: serverTimestamp(), lastDestination: outStock.destination });

          tx.set(doc(movementsColRef()), {
            type: "out",
            itemKey: selected.itemKey,
            qty,
            destination: outStock.destination,
            from: { slotId: selected.slotId, shelf: selected.shelf, level: selected.level },
            userId: user?.uid || null,
            at: serverTimestamp()
          });
        });

        setOutStock({ entryId: "", qty: "", destination: "produktion" });
        setActiveTab("inventory");
        pushToast("ok", "Auslagerung gespeichert.");
      } catch (err) {
        console.error("Remove error:", err);
        pushToast("err", "Fehler beim Auslagern (siehe Konsole).");
      }
    };

    // manual move (Teilmenge)
    const handleMoveStock = async (e) => {
      e.preventDefault();
      const selected = entryOptions.find(x => x.entryId === moveStock.entryId);
      if (!selected) return;

      const qty = Number(moveStock.qty);
      if (!qty || qty <= 0) return;

      if (qty > selected.quantity) { pushToast("err", "Menge ist größer als Bestand."); return; }

      const targetShelf = moveStock.targetShelf;
      const targetLevel = Number(moveStock.targetLevel);
      const targetSlotId = `${targetShelf}_L${targetLevel}`;

      const sourceRef = itemDocRef(selected.slotId, selected.itemKey);
      const targetSlotRef = slotDocRef(targetSlotId);
      const targetItemRef = itemDocRef(targetSlotId, selected.itemKey);

      try {
        await runTransaction(db, async (tx) => {
          const sSnap = await tx.get(sourceRef);
          const sPrev = sSnap.exists() ? (Number(sSnap.data().quantity) || 0) : 0;
          if (sPrev < qty) throw new Error("Insufficient stock in transaction (move)");

          const sNext = sPrev - qty;
          if (sNext <= 0) tx.delete(sourceRef);
          else tx.update(sourceRef, { quantity: sNext, updatedAt: serverTimestamp() });

          tx.set(targetSlotRef, { appId: APP_ID, slotId: targetSlotId, shelf: targetShelf, level: targetLevel, updatedAt: serverTimestamp() }, { merge: true });

          const tSnap = await tx.get(targetItemRef);
          const tPrev = tSnap.exists() ? (Number(tSnap.data().quantity) || 0) : 0;
          const tNext = tPrev + qty;

          if (tSnap.exists()) {
            tx.update(targetItemRef, { quantity: tNext, updatedAt: serverTimestamp() });
          } else {
            tx.set(targetItemRef, {
              appId: APP_ID, slotId: targetSlotId, shelf: targetShelf, level: targetLevel,
              itemKey: selected.itemKey, type: "steg",
              quantity: tNext,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp()
            });
          }

          tx.set(doc(movementsColRef()), {
            type: "move",
            itemKey: selected.itemKey,
            qty,
            from: { slotId: selected.slotId, shelf: selected.shelf, level: selected.level },
            to: { slotId: targetSlotId, shelf: targetShelf, level: targetLevel },
            userId: user?.uid || null,
            at: serverTimestamp()
          });
        });

        setMoveStock({ entryId: "", targetShelf: "C1", targetLevel: 1, qty: "" });
        setActiveTab("inventory");
        pushToast("ok", "Umlagerung gespeichert.");
      } catch (err) {
        console.error("Move error:", err);
        pushToast("err", "Fehler beim Umlagern (siehe Konsole).");
      }
    };

    // Scan batch move: source shelf -> top occupied level + ALL items, target shelf -> next free level
   const handleBatchMoveFromSlot = async ({ sourceShelf, sourceLevel, targetShelf }) => {
  const sourceSlotId = `${sourceShelf}_L${sourceLevel}`;
  const entries = slotMap.get(`${sourceShelf}|${sourceLevel}`) || [];
  if (!entries.length) {
    pushToast("err", `Quelle ${sourceShelf}-L${sourceLevel} ist leer.`);
    return;
  }

  // Ziel: nächste freie Ebene (von oben nach unten)
  let targetLevel = pickNextFreeLevel(slotMap, targetShelf, levels);
  if (!targetLevel) {
    pushToast("err", `Zielregal ${targetShelf} hat keine freie Ebene (Fallback L1).`);
    targetLevel = 1;
  }
  const targetSlotId = `${targetShelf}_L${targetLevel}`;

  const targetSlotRef = slotDocRef(targetSlotId);

  try {
    await runTransaction(db, async (tx) => {
      // -------------------------
      // 1) READ PHASE (ALLES LESEN)
      // -------------------------
      const pairs = entries.map(e => {
        const itemKey = e.itemKey;
        return {
          itemKey,
          sRef: itemDocRef(sourceSlotId, itemKey),
          tRef: itemDocRef(targetSlotId, itemKey),
        };
      });

      // Alle Reads in Arrays sammeln
      const sSnaps = [];
      const tSnaps = [];

      for (const p of pairs) {
        sSnaps.push(await tx.get(p.sRef));
      }
      for (const p of pairs) {
        tSnaps.push(await tx.get(p.tRef));
      }

      // Plan bauen (was wird wirklich bewegt?)
      const plan = [];
      for (let i = 0; i < pairs.length; i++) {
        const p = pairs[i];
        const sSnap = sSnaps[i];
        const tSnap = tSnaps[i];

        const sQty = sSnap.exists() ? (Number(sSnap.data().quantity) || 0) : 0;
        if (sQty <= 0) continue;

        const tQty = tSnap.exists() ? (Number(tSnap.data().quantity) || 0) : 0;
        plan.push({
          itemKey: p.itemKey,
          sRef: p.sRef,
          tRef: p.tRef,
          sQty,
          tQty,
          tExists: tSnap.exists()
        });
      }

      if (!plan.length) {
        throw new Error("Quelle hat keine positiven Mengen (TX).");
      }

      // -------------------------
      // 2) WRITE PHASE (NUR SCHREIBEN)
      // -------------------------
      tx.set(
        targetSlotRef,
        { appId: APP_ID, slotId: targetSlotId, shelf: targetShelf, level: targetLevel, updatedAt: serverTimestamp() },
        { merge: true }
      );

      const movedItems = [];

      for (const p of plan) {
        // Quelle komplett entfernen
        tx.delete(p.sRef);

        // Ziel addieren/erzeugen
        const next = p.tQty + p.sQty;
        if (p.tExists) {
          tx.update(p.tRef, { quantity: next, updatedAt: serverTimestamp() });
        } else {
          tx.set(p.tRef, {
            appId: APP_ID,
            slotId: targetSlotId,
            shelf: targetShelf,
            level: targetLevel,
            itemKey: p.itemKey,
            type: "steg",
            quantity: next,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
          });
        }

        movedItems.push({ itemKey: p.itemKey, qty: p.sQty });
      }

      // Log
      tx.set(doc(movementsColRef()), {
        type: "move_batch",
        from: { slotId: sourceSlotId, shelf: sourceShelf, level: sourceLevel },
        to: { slotId: targetSlotId, shelf: targetShelf, level: targetLevel },
        items: movedItems,
        userId: user?.uid || null,
        at: serverTimestamp()
      });
    });

    pushToast("ok", `Umlagert: ${sourceShelf}-L${sourceLevel} → ${targetShelf}-L${targetLevel}`);
  } catch (err) {
    console.error("Batch move error:", err);
    pushToast("err", "Fehler beim Scan-Umlagern (siehe Konsole).");
  }
};
          {/* INVENTORY */}
          {activeTab === "inventory" && (
            <div className="space-y-4">
              <div className="relative">
                <input
                  placeholder="Suche Steg, Regal (C1...) oder Profil/AWB..."
                  value={searchQuery}
                  onChange={e => setSearchQuery(e.target.value)}
                  className="w-full px-6 py-4 bg-white rounded-3xl shadow-lg outline-none font-bold text-slate-800 border-2 border-transparent focus:border-yellow-400 transition-all"
                />
                <div className="absolute right-5 top-4 text-slate-300"><Icon name="search" /></div>
              </div>

              <div className="flex gap-2">
                <button onClick={exportInventoryCSV}
                  className="flex-1 py-4 bg-slate-900 text-yellow-500 rounded-[1.5rem] font-black uppercase shadow active:scale-95">
                  Bestand CSV export
                </button>
                <button onClick={() => setActiveTab("history")}
                  className="px-5 py-4 bg-white border border-slate-200 rounded-[1.5rem] font-black uppercase text-slate-800 shadow-sm active:scale-95">
                  Historie
                </button>
              </div>

              <div className="space-y-3">
                {filteredSlots.length === 0 ? (
                  <div className="bg-white p-6 rounded-[2rem] shadow-sm border border-slate-200 text-slate-500 font-bold italic">
                    Keine Treffer / kein Bestand.
                  </div>
                ) : filteredSlots.map(slot => (
                  <div key={`${slot.shelf}|${slot.level}`} className="bg-white p-5 rounded-[2rem] shadow-sm border border-slate-200">
                    <div className="flex items-center justify-between mb-3">
                      <span className="text-[15px] font-black bg-slate-900 text-yellow-500 px-3 py-1 rounded-full">
                        {slot.shelf} - L{slot.level}
                      </span>
                      <span className="text-[11px] font-black text-slate-500 uppercase">
                        {slot.entries.length} Sorten
                      </span>
                    </div>

                    <div className="space-y-2">
                      {slot.entries.map(entry => {
                        const linked = getLinkedAWBs(entry.itemKey);
                        return (
                          <div key={entry.id} className="flex items-center justify-between bg-slate-50 rounded-2xl px-4 py-3 border border-slate-100">
                            <div className="min-w-0 pr-3">
                              <div className="font-black text-slate-800 truncate">{entry.itemKey}</div>
                              <div className="text-[11px] text-slate-400 font-bold uppercase truncate">
                                {linked.length ? `Ref: ${linked.join(" | ")}` : "Einzel-Komponente"}
                              </div>
                            </div>
                            <div className="bg-white text-slate-800 px-4 py-2 rounded-xl font-black text-lg border border-slate-200">
                              {entry.quantity}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* HISTORY */}
          {activeTab === "history" && (
            <div className="space-y-4">
              <div className="bg-white p-5 rounded-[2rem] shadow-sm border border-slate-200">
                <div className="flex items-center justify-between gap-3">
                  <div>
                    <div className="text-[10px] font-black uppercase text-slate-400">Bewegungs-Historie</div>
                    <div className="font-black text-slate-800">Letzte Buchungen (live)</div>
                  </div>
                  <button onClick={exportMovementsCSV}
                    className="px-4 py-3 rounded-2xl bg-slate-900 text-yellow-500 font-black text-xs uppercase shadow active:scale-95">
                    Historie CSV
                  </button>
                </div>

                <div className="mt-4 relative">
                  <input
                    placeholder="Filter: Steg, Slot (C12_L3), Typ, userId..."
                    value={historyQuery}
                    onChange={e => setHistoryQuery(e.target.value)}
                    className="w-full px-6 py-4 bg-slate-50 rounded-3xl outline-none font-bold text-slate-800 border-2 border-slate-100 focus:border-yellow-400 transition-all"
                  />
                  <div className="absolute right-5 top-4 text-slate-300"><Icon name="search" /></div>
                </div>
              </div>

              {filteredMovements.length === 0 ? (
                <div className="bg-white p-6 rounded-[2rem] shadow-sm border border-slate-200 text-slate-500 font-bold italic">
                  Keine Buchungen vorhanden.
                </div>
              ) : (
                <div className="space-y-3">
                  {filteredMovements.slice(0, 200).map(m => {
                    const typeLabel =
                      m.type === "in" ? "EINGANG" :
                      m.type === "out" ? "AUSGANG" :
                      m.type === "move" ? "MOVE" :
                      m.type === "move_batch" ? "MOVE (BATCH)" :
                      (m.type || "???");

                    const typeStyle =
                      m.type === "in" ? "bg-emerald-100 text-emerald-700" :
                      m.type === "out" ? "bg-rose-100 text-rose-700" :
                      m.type === "move" ? "bg-blue-100 text-blue-700" :
                      m.type === "move_batch" ? "bg-indigo-100 text-indigo-700" :
                      "bg-slate-100 text-slate-700";

                    const fromSlot = m?.from?.slotId ? `${m.from.slotId}` : "";
                    const toSlot = m?.to?.slotId ? `${m.to.slotId}` : "";

                    const qtyShown =
                      m.type === "move_batch"
                        ? (Array.isArray(m.items) ? m.items.reduce((s, it) => s + (Number(it.qty)||0), 0) : 0)
                        : (Number(m.qty) || 0);

                    return (
                      <div key={m.id} className="bg-white p-5 rounded-[2rem] shadow-sm border border-slate-200">
                        <div className="flex items-start justify-between gap-3">
                          <div className="min-w-0">
                            <div className="flex items-center gap-2 flex-wrap">
                              <span className={`px-3 py-1 rounded-full text-[10px] font-black ${typeStyle}`}>{typeLabel}</span>
                              <span className="text-[11px] font-black text-slate-500">{fmtDateTime(m.at)}</span>
                            </div>

                            <div className="mt-2 font-black text-slate-900 truncate">
                              {m.type === "move_batch" ? `${fromSlot || "-"} → ${toSlot || "-"}` : (m.itemKey || "-")}
                            </div>

                            <div className="text-[11px] text-slate-500 font-bold mt-1">
                              {m.type === "in" && <>Quelle: <span className="text-slate-800">{m.source || "-"}</span> → Ziel: <span className="text-slate-800">{toSlot || "-"}</span></>}
                              {m.type === "out" && <>Von: <span className="text-slate-800">{fromSlot || "-"}</span> → Zweck: <span className="text-slate-800">{m.destination || "-"}</span></>}
                              {m.type === "move" && <>Von: <span className="text-slate-800">{fromSlot || "-"}</span> → Nach: <span className="text-slate-800">{toSlot || "-"}</span></>}
                              {m.type === "move_batch" && <span className="text-slate-800">{Array.isArray(m.items) ? `${m.items.length} Sorten` : ""}</span>}
                            </div>

                            {m.type === "move_batch" && Array.isArray(m.items) && m.items.length ? (
                              <div className="mt-2 text-[11px] text-slate-600 font-bold">
                                {m.items.slice(0, 6).map((it, i) => (
                                  <span key={i} className="inline-block mr-2">
                                    {it.itemKey} ({it.qty})
                                  </span>
                                ))}
                                {m.items.length > 6 ? <span className="text-slate-400">…</span> : null}
                              </div>
                            ) : null}

                            <div className="text-[10px] text-slate-400 font-bold mt-2 truncate">
                              user: {m.userId || "-"}
                            </div>
                          </div>

                          <div className="shrink-0 bg-slate-900 text-yellow-500 px-4 py-2 rounded-xl font-black text-lg border border-slate-800">
                            {qtyShown}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                  <div className="text-center text-[10px] text-slate-500 font-bold">
                    * Anzeige limitiert auf 200 Einträge (CSV exportiert alle geladenen).
                  </div>
                </div>
              )}
            </div>
          )}

          {/* ADD */}
          {activeTab === "add" && (
            <div className="bg-white p-8 rounded-[2.5rem] shadow-xl border border-slate-200 space-y-6">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-emerald-100 text-emerald-600 rounded-xl"><Icon name="arrow-down-to-dot" /></div>
                <h3 className="font-black uppercase text-slate-800 italic text-xl">Wareneingang</h3>
              </div>

              <div className="flex gap-2">
                <button
                  type="button"
                  onClick={() => { setScanAddMode("item"); setScanAddOpen(true); }}
                  className="flex-1 py-4 rounded-[1.25rem] bg-slate-900 text-yellow-500 font-black uppercase shadow active:scale-95"
                >
                  Scan: Steg/Artikel
                </button>
                <button
                  type="button"
                  onClick={() => { setScanAddMode("slot"); setScanAddOpen(true); }}
                  className="flex-1 py-4 rounded-[1.25rem] bg-yellow-500 text-slate-900 font-black uppercase shadow active:scale-95"
                >
                  Scan: Platz
                </button>
              </div>

              <form onSubmit={handleAddStock} className="space-y-5">
                <div className="flex gap-2 p-1 bg-slate-100 rounded-2xl">
                  <button type="button"
                    onClick={() => setNewStock({ ...newStock, source: "anlieferung" })}
                    className={`flex-1 py-3 rounded-xl text-[10px] font-black uppercase transition-all ${
                      newStock.source === "anlieferung" ? "bg-white shadow-sm text-emerald-600" : "text-slate-400"
                    }`}>Anlieferung</button>
                  <button type="button"
                    onClick={() => setNewStock({ ...newStock, source: "produktion" })}
                    className={`flex-1 py-3 rounded-xl text-[10px] font-black uppercase transition-all ${
                      newStock.source === "produktion" ? "bg-white shadow-sm text-blue-600" : "text-slate-400"
                    }`}>Rücklauf</button>
                </div>

                <div className="space-y-1">
                  <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Steg auswählen</label>
                  <select required value={newStock.itemKey} onChange={e => setNewStock({ ...newStock, itemKey: e.target.value })}
                    className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 appearance-none outline-none focus:border-emerald-400">
                    <option value="">-- Typ wählen --</option>
                    {stegItems.map(s => <option key={s.id} value={s.code}>{s.code}</option>)}
                  </select>
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-1">
                    <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Regal (C)</label>
                    <select value={newStock.shelf} onChange={e => setNewStock({ ...newStock, shelf: e.target.value })}
                      className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none">
                      {shelves.map(s => <option key={s} value={s}>{s}</option>)}
                    </select>
                  </div>
                  <div className="space-y-1">
                    <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Ebene</label>
                    <select value={newStock.level} onChange={e => setNewStock({ ...newStock, level: Number(e.target.value) })}
                      className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none">
                      {levels.map(l => <option key={l} value={l}>Ebene {l}</option>)}
                    </select>
                  </div>
                </div>

                <div className="space-y-1">
                  <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Stückzahl</label>
                  <input required type="number" min="1" placeholder="Menge..."
                    value={newStock.qty} onChange={e => setNewStock({ ...newStock, qty: e.target.value })}
                    className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none focus:border-emerald-400" />
                </div>

                <button type="submit" className="w-full py-5 bg-emerald-600 text-white rounded-[1.5rem] font-black uppercase shadow-lg shadow-emerald-600/20 active:scale-95 transition-all">
                  Einlagern bestätigen
                </button>
              </form>
            </div>
          )}

          {/* MOVE */}
          {activeTab === "move" && (
            <div className="bg-white p-8 rounded-[2.5rem] shadow-xl border border-slate-200 space-y-6">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-blue-100 text-blue-600 rounded-xl"><Icon name="shuffle" /></div>
                <h3 className="font-black uppercase text-slate-800 italic text-xl">Umlagern</h3>
              </div>

              {/* Scan batch move */}
              <div className="flex gap-2">
                <button
                  type="button"
                  onClick={() => { setScanMoveMode("source"); setScanMoveOpen(true); }}
                  className="flex-1 py-4 rounded-[1.25rem] bg-slate-900 text-yellow-500 font-black uppercase shadow active:scale-95"
                >
                  Scan Quelle
                </button>
                <button
                  type="button"
                  onClick={() => { setScanMoveMode("target"); setScanMoveOpen(true); }}
                  className="flex-1 py-4 rounded-[1.25rem] bg-yellow-500 text-slate-900 font-black uppercase shadow active:scale-95"
                >
                  Scan Ziel
                </button>
              </div>

              <div className="text-[11px] text-slate-500 font-bold px-1">
                Quelle: Regal scannen (z.B. <span className="text-slate-800">C12</span>) → nimmt <span className="text-slate-800">oberste belegte Ebene</span> und lagert <span className="text-slate-800">alle Stege dort</span> um.<br/>
                Ziel: Regal scannen (z.B. <span className="text-slate-800">C13</span>) → Einlagerung in <span className="text-slate-800">nächste freie Ebene</span>.
              </div>

              {scanMoveBatch.hasSource && (
                <div className="p-4 bg-blue-50 border border-blue-100 rounded-2xl">
                  <div className="text-[10px] font-black uppercase text-blue-700">Scan-Umlagern: Quelle gesetzt</div>
                  <div className="font-black text-slate-900 mt-1">
                    {scanMoveBatch.sourceShelf}-L{scanMoveBatch.sourceLevel} • {scanMoveBatch.entries.length} Sorten
                  </div>
                  <div className="text-[11px] text-slate-600 font-bold mt-1">
                    Jetzt Ziel scannen (z.B. C13).
                  </div>
                  <button
                    type="button"
                    onClick={() => { setScanMoveBatch({ hasSource:false, sourceShelf:null, sourceLevel:null, sourceSlotId:null, entries: [] }); setScanMoveMode("source"); }}
                    className="mt-3 px-4 py-2 rounded-xl bg-white border border-slate-200 font-black text-slate-800 active:scale-95"
                  >
                    Quelle zurücksetzen
                  </button>
                </div>
              )}

              {/* Manual move (stays) */}
              <div className="pt-2 border-t border-slate-100">
                <div className="text-[10px] font-black uppercase text-slate-400">Manuell umlagern (Teilmenge)</div>
              </div>

              <form onSubmit={handleMoveStock} className="space-y-5">
                <div className="space-y-1">
                  <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Was umlagern?</label>
                  <select required value={moveStock.entryId}
                    onChange={e => {
                      const entryId = e.target.value;
                      const entry = entryOptions.find(x => x.entryId === entryId);
                      setMoveStock({ ...moveStock, entryId, qty: entry ? String(Math.min(entry.quantity, 1)) : "" });
                    }}
                    className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 appearance-none outline-none focus:border-blue-400">
                    <option value="">-- Bestand wählen --</option>
                    {entryOptions.map(e => (
                      <option key={e.entryId} value={e.entryId}>
                        {e.shelf}-L{e.level} | {e.itemKey} ({e.quantity} Stk)
                      </option>
                    ))}
                  </select>
                </div>

                {(() => {
                  const sel = entryOptions.find(x => x.entryId === moveStock.entryId);
                  const max = sel ? sel.quantity : 0;
                  return (
                    <div className="space-y-1">
                      <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Stückzahl</label>
                      <input
                        type="number"
                        min="1"
                        max={max || 1}
                        placeholder="Menge..."
                        value={moveStock.qty}
                        onChange={e => setMoveStock({ ...moveStock, qty: e.target.value })}
                        className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none focus:border-blue-400"
                      />
                      <p className="text-[9px] text-slate-400 ml-4 italic mt-1">* Max: {max || "-"} Stk</p>
                    </div>
                  );
                })()}

                <div className="grid grid-cols-2 gap-4 pt-4 border-t border-slate-100">
                  <div className="space-y-1">
                    <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Ziel Regal</label>
                    <select value={moveStock.targetShelf} onChange={e => setMoveStock({ ...moveStock, targetShelf: e.target.value })}
                      className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none">
                      {shelves.map(s => <option key={s} value={s}>{s}</option>)}
                    </select>
                  </div>
                  <div className="space-y-1">
                    <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Ziel Ebene</label>
                    <select value={moveStock.targetLevel} onChange={e => setMoveStock({ ...moveStock, targetLevel: Number(e.target.value) })}
                      className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none">
                      {levels.map(l => <option key={l} value={l}>Ebene {l}</option>)}
                    </select>
                  </div>
                </div>

                <button type="submit" disabled={!moveStock.entryId}
                  className={`w-full py-5 text-white rounded-[1.5rem] font-black uppercase shadow-lg active:scale-95 transition-all ${
                    moveStock.entryId ? "bg-blue-600 shadow-blue-600/20" : "bg-slate-300 shadow-none cursor-not-allowed"
                  }`}>
                  Umlagerung ausführen
                </button>
              </form>
            </div>
          )}

          {/* OUTBOUND */}
          {activeTab === "outbound" && (
            <div className="bg-white p-8 rounded-[2.5rem] shadow-xl border border-slate-200 space-y-6">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-rose-100 text-rose-600 rounded-xl"><Icon name="arrow-up-right-from-circle" /></div>
                <h3 className="font-black uppercase text-slate-800 italic text-xl">Warenausgang</h3>
              </div>

              <form onSubmit={handleRemoveStock} className="space-y-5">
                <div className="space-y-1">
                  <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Eintrag wählen</label>
                  <select required value={outStock.entryId} onChange={e => setOutStock({ ...outStock, entryId: e.target.value })}
                    className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 appearance-none outline-none focus:border-rose-400">
                    <option value="">-- Bestand wählen --</option>
                    {entryOptions.map(e => (
                      <option key={e.entryId} value={e.entryId}>
                        {e.shelf}-L{e.level} | {e.itemKey} ({e.quantity} Stk)
                      </option>
                    ))}
                  </select>
                </div>

                <div className="space-y-1">
                  <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Verwendung</label>
                  <select value={outStock.destination} onChange={e => setOutStock({ ...outStock, destination: e.target.value })}
                    className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none">
                    <option value="produktion">Produktion / Montage</option>
                    <option value="ausschuss">Ausschuss / Defekt</option>
                    <option value="inventur">Korrektur</option>
                  </select>
                </div>

                <div className="space-y-1">
                  <label className="text-[10px] font-black uppercase text-slate-400 ml-4">Entnahmemenge</label>
                  <input required type="number" min="1" placeholder="Menge..."
                    value={outStock.qty} onChange={e => setOutStock({ ...outStock, qty: e.target.value })}
                    className="w-full p-4 bg-slate-50 rounded-2xl font-bold border-2 border-slate-100 outline-none focus:border-rose-400" />
                </div>

                <button type="submit" className="w-full py-5 bg-rose-600 text-white rounded-[1.5rem] font-black uppercase shadow-lg shadow-rose-600/20 active:scale-95 transition-all">
                  Auslagern bestätigen
                </button>
              </form>
            </div>
          )}
        </main>

        {/* --- Slot Popup (Dashboard click) --- */}
        {slotPopup.open && (() => {
          const shelf = slotPopup.shelf;
          const level = slotPopup.level;
          const entries = slotMap.get(`${shelf}|${level}`) || [];
          return (
            <div className="fixed inset-0 z-[1500] bg-black/60 backdrop-blur-sm flex items-end sm:items-center justify-center p-4">
              <div className="w-full max-w-lg bg-white rounded-[2rem] shadow-2xl border border-slate-200 overflow-hidden">
                <div className="p-5 flex items-center justify-between">
                  <div>
                    <div className="text-[10px] font-black uppercase text-slate-400">Platz</div>
                    <div className="font-black text-slate-900 text-lg">{shelf} - L{level}</div>
                  </div>
                  <button
                    onClick={() => setSlotPopup({ open: false, shelf: null, level: null })}
                    className="px-3 py-2 rounded-xl bg-slate-100 font-black text-slate-700 active:scale-95"
                  >
                    Schließen
                  </button>
                </div>

                <div className="px-5 pb-5 space-y-3">
                  {entries.length === 0 ? (
                    <div className="p-5 bg-slate-50 border border-slate-100 rounded-2xl text-slate-500 font-bold">
                      Platz ist leer.
                    </div>
                  ) : (
                    <div className="space-y-2">
                      {entries.map(e => (
                        <div key={e.id} className="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-2xl px-4 py-3">
                          <div className="min-w-0 pr-3">
                            <div className="font-black text-slate-900 truncate">{e.itemKey}</div>
                            <div className="text-[11px] text-slate-400 font-bold uppercase truncate">
                              {getLinkedAWBs(e.itemKey).length ? `Ref: ${getLinkedAWBs(e.itemKey).join(" | ")}` : "Einzel-Komponente"}
                            </div>
                          </div>
                          <div className="px-4 py-2 rounded-xl bg-white border border-slate-200 font-black text-slate-900">
                            {e.quantity}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}

                  <div className="flex gap-2 pt-2">
                    <button
                      onClick={() => {
                        setSlotPopup({ open:false, shelf:null, level:null });
                        setActiveTab("add");
                        setNewStock(s => ({ ...s, shelf, level }));
                      }}
                      className="flex-1 py-4 rounded-[1.25rem] bg-emerald-600 text-white font-black uppercase shadow active:scale-95"
                    >
                      Einlagern hier
                    </button>
                    <button
                      onClick={() => {
                        setSlotPopup({ open:false, shelf:null, level:null });
                        setActiveTab("inventory");
                        setSearchQuery(`${shelf}`);
                      }}
                      className="px-5 py-4 rounded-[1.25rem] bg-slate-900 text-yellow-500 font-black uppercase shadow active:scale-95"
                    >
                      Bestand
                    </button>
                  </div>
                </div>
              </div>
            </div>
          );
        })()}

        {/* --- Scanner: ADD --- */}
        <ScannerModal
          open={scanAddOpen}
          title={scanAddMode === "item" ? "Scan Steg/Artikel" : "Scan Platz (C12_L3 oder C12)"}
          onClose={() => setScanAddOpen(false)}
          onResult={(raw) => {
            const p = parseScanCode(raw);

            // Item scan
            if (scanAddMode === "item") {
              if (p.kind === "item") {
                setNewStock(s => ({ ...s, itemKey: p.itemKey }));
                pushToast("ok", `Steg gesetzt: ${p.itemKey}`);
              } else {
                pushToast("err", "Bitte einen Steg/Artikel-Code scannen.");
              }
              setScanAddOpen(false);
              return;
            }

            // Slot/Shelf scan
            if (p.kind === "slot") {
              setNewStock(s => ({ ...s, shelf: p.shelf, level: p.level }));
              pushToast("ok", `Platz gesetzt: ${p.shelf}-L${p.level}`);
              setScanAddOpen(false);
              return;
            }

            if (p.kind === "shelf") {
              const nextFree = pickNextFreeLevel(slotMap, p.shelf, levels);
              const lvl = nextFree ?? 1; // fallback
              setNewStock(s => ({ ...s, shelf: p.shelf, level: lvl }));
              pushToast(nextFree ? "ok" : "err", nextFree ? `Regal ${p.shelf} → freie Ebene L${lvl}` : `Regal voll, fallback L${lvl}`);
              setScanAddOpen(false);
              return;
            }

            pushToast("err", "Unbekannter Code für Platz-Scan.");
            setScanAddOpen(false);
          }}
        />

        {/* --- Scanner: MOVE (Batch logic) --- */}
        <ScannerModal
          open={scanMoveOpen}
          title={scanMoveMode === "source" ? "Scan Quelle (C12 oder C12_L3)" : "Scan Ziel (C13 oder C13_Lx)"}
          onClose={() => setScanMoveOpen(false)}
          onResult={(raw) => {
            const p = parseScanCode(raw);

            // SOURCE scan
            if (scanMoveMode === "source") {
              let shelf = null, level = null;

              if (p.kind === "slot") { shelf = p.shelf; level = p.level; }
              else if (p.kind === "shelf") {
                shelf = p.shelf;
                level = pickTopOccupiedLevel(slotMap, shelf, levels);
                if (!level) {
                  pushToast("err", `Regal ${shelf} ist komplett leer.`);
                  setScanMoveOpen(false);
                  return;
                }
              } else {
                pushToast("err", "Bitte Quelle als Regal/Slot scannen (z.B. C12 oder C12_L3).");
                setScanMoveOpen(false);
                return;
              }

              const entries = slotMap.get(`${shelf}|${level}`) || [];
              if (!entries.length) {
                pushToast("err", `Quelle ${shelf}-L${level} ist leer.`);
                setScanMoveOpen(false);
                return;
              }

              setScanMoveBatch({
                hasSource: true,
                sourceShelf: shelf,
                sourceLevel: level,
                sourceSlotId: `${shelf}_L${level}`,
                entries: entries.map(e => ({ itemKey: e.itemKey, quantity: e.quantity, slotId: e.slotId, shelf: e.shelf, level: e.level }))
              });

              pushToast("ok", `Quelle gesetzt: ${shelf}-L${level} (alle Stege) — jetzt Ziel scannen`);
              setScanMoveMode("target");
              setScanMoveOpen(false);
              return;
            }

            // TARGET scan
            if (scanMoveMode === "target") {
              if (!scanMoveBatch.hasSource) {
                pushToast("err", "Bitte zuerst die Quelle scannen.");
                setScanMoveOpen(false);
                return;
              }

              let targetShelf = null;
              if (p.kind === "shelf") targetShelf = p.shelf;
              else if (p.kind === "slot") targetShelf = p.shelf;
              else {
                pushToast("err", "Bitte Ziel als Regal/Slot scannen (z.B. C13 oder C13_L2).");
                setScanMoveOpen(false);
                return;
              }

              handleBatchMoveFromSlot({
                sourceShelf: scanMoveBatch.sourceShelf,
                sourceLevel: scanMoveBatch.sourceLevel,
                targetShelf
              });

              setScanMoveBatch({ hasSource:false, sourceShelf:null, sourceLevel:null, sourceSlotId:null, entries: [] });
              setScanMoveMode("source");
              setScanMoveOpen(false);
            }
          }}
        />

        <nav className="fixed bottom-6 left-1/2 -translate-x-1/2 w-[92%] max-w-[620px] glass-effect rounded-[2.5rem] p-2 flex justify-around shadow-2xl border border-white/10 z-[100]">
          <NavBtn active={activeTab === "dashboard"} onClick={() => setActiveTab("dashboard")} icon="layout-dashboard" label="Home" />
          <NavBtn active={activeTab === "inventory"} onClick={() => setActiveTab("inventory")} icon="boxes" label="Bestand" />
          <NavBtn active={activeTab === "history"} onClick={() => setActiveTab("history")} icon="history" label="Log" color="slate" />
          <NavBtn active={activeTab === "add"} onClick={() => setActiveTab("add")} icon="arrow-down-to-dot" label="Eingang" color="emerald" />
          <NavBtn active={activeTab === "move"} onClick={() => setActiveTab("move")} icon="shuffle" label="Umlagern" color="blue" />
          <NavBtn active={activeTab === "outbound"} onClick={() => setActiveTab("outbound")} icon="arrow-up-right-from-circle" label="Ausgang" color="rose" />
        </nav>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(<App />);
</script>
</body>
</html>
